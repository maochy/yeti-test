\externaldocument{chapter3}
\chapter{York Extensible Testing Infrastructure}
\label{chap:yeti_3}

%\section{Random Testing}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%													        %
%														 %			
% YETI Section Starts here									 %
%														 %		
%														 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%In this chapter we describe York Extensible Testing Infrastructure (YETI). YETI is used as a platform for implementation of all the strategies developed in the current research study. 

\section{Overview}
The York Extensible Testing Infrastructure (YETI) is an automated random testing tool developed by Manuel Oriol~\cite{Oriol2011yeti}. It is capable of testing programs written in Java, JML and .NET languages~\cite{oriol2010testing}. YETI takes the program byte-code as input and executes it with randomly generated syntactically-correct inputs to find a failure. It runs at a high level of performance with $10^6$ calls (to drivers and stub methods) per minute on Java code. One of its prominent features is the Graphical User Interface (GUI), which makes YETI user-friendly and provides an option to change the testing parameters in real time. It can also distribute large testing tasks in the cloud for parallel execution~\cite{oriol2010yeti}. The main motivation for developing YETI is provision of a testing workbench to testers and developers for research. YETI by design is easily extendable to facilitate inclusion of new languages and testing strategies. Several researchers \cite{oriol2010testing, oriol2010yeti, Dimitraiadis2009, Khawaja2010} have contributed various features and strategies to the YETI project. The current study extends YETI with three more test strategies i.e. DSSR \cite{ahmad2014dirt}, ADFD \cite{ahmad2013adfd} and ADFD$^+$ \cite{ahmad2014adfd2} for software testing and graphical front-end to enable its execution from any GUI which supports Java. Latest version of YETI can be downloaded freely from \url{www.yetitest.org}. Figure \ref{fig:yetiOverview} briefly presents the working process of YETI. 

\begin{figure}[h]
	\centering
	\includegraphics[width=14.5cm, height=3.5cm]{chapter3/workingProcess.png}
	\caption{Working process of YETI}
	\label{fig:yetiOverview}
\end{figure}


\section{Design}
YETI is a lightweight platform with around 10000 lines of code. It has been designed with the provision of extensibility for future growth. YETI enforces strong decoupling between test strategies and the actual language constructs, which adds new binding, without any modification in the available test strategies. YETI can be divided into three main parts on the basis of functionality: the core infrastructure, the strategy and the language-specific binding. Each part is briefly described below. 

\subsection{Core Infrastructure of YETI}
The core infrastructure of YETI provides extendibility through specialization. The abstract classes included in this section can be extended to create new strategies and language bindings. It is responsible for test data generation, test process management and test report production. The core infrastructure of YETI is split into four packages, i.e.~\verb+yeti+, \verb+yeti.environments+, \verb+yeti.monitoring+ and~\verb+yeti.strategies+. The package~\verb+yeti+ uses
classes from \verb+yeti.monitoring+ and \verb+yeti.strategies+ packages and calls classes in the \verb+yeti.environment+ package as shown in the Figure \ref{fig:yetiCore}.

\bigskip
\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, height=9cm]{chapter3/yetiStructure.png}
	\smallskip
	\caption{Main packages of YETI with dependencies }
	\label{fig:yetiCore}
\end{figure}
\bigskip
\bigskip
\bigskip
The most essential classes included in the YETI core infrastructure are:
\begin{enumerate}
\item {\textbf{Yeti}} is the entry point to the tool YETI and contains the main method. It parses the arguments, sets up the environment, initializes the testing and delivers the reports of the test results.
\item {\textbf{YetiLog}} prints debugging and testing logs. 
\item {\textbf{YetiLogProcessor}} is an interface for processing testing logs.
\item {\textbf{YetiEngine}} binds~\verb+YetiStrategy+ and~\verb+YetiTestManager+ together and carries-out the actual testing process.
\item {\textbf{YetiTestManager}} makes the actual calls based on the~\verb+YetiEngine+ configuration, and activates the~\verb+YetiStrategy+ to generate test data and select the routines.
\item {\textbf{YetiProgrammingLanguageProperties}} is a place-holder for all language-related instances.
\item {\textbf{YetiInitializer}} is an abstract class for test initialization.
\end{enumerate}

\subsection{Strategy}
The strategy defines a specific way to generate test inputs. The strategy section consist of seven essential strategies stated below:
\begin{enumerate}
\item {\textbf{YetiStrategy}} is an abstract class which provides an interface for every strategy in YETI.
\item {\textbf{YetiRandomStrategy}} implements the random strategy and generates random values for testing. It allows the user to adjust null values probability and percentage of creating new objects for the test session. 
\item {\textbf{YetiRandomPlusStrategy}} extends the random strategy by adding values to the list of interesting values. It allows the user to adjust the percentage of using interesting values in the test session.
\item {\textbf{YetiDSSRStrategy}} extends YetiRandomPlusStrategy by adding values surrounding the failure finding value. The strategy is described in detail in Chapter~\ref{chap:DSSR}.
\item {\textbf{YetiADFDStrategy}} extends YetiRandomPlusStrategy by adding the feature of graphical representation of failures and their domains in the specified lower and upper bound. The strategy is described in detail in Chapter~\ref{chap:ADFD}.
\item {\textbf{YetiADFDPlusStrategy}} extends ADFD strategy by adding the feature of graphical representation of failures and failure domains in a given radius in simplified form. The strategy is described in detail in Chapter~\ref{chap:ADFD+}.
\item {\textbf{YetiRandomDecreasingStrategy}} extends the YetiRandomPlusStrategy in which all the three probability values (null values, new objects, interesting values) are 100\% at the beginning and decreases to 0 at the end of the test.
\item {\textbf{YetiRandomPeriodicStrategy}} extends the YetiRandomPlusStrategy in which all the three probability values (null values, new objects, interesting values) decreases and increases at random within the given range.
\end{enumerate}






\subsection{Language-specific Binding}
The language-specific binding facilitates modelling of programming languages. It is extended to provide support for a new language in YETI. The language-specific binding includes the following classes:
\begin{enumerate}
\item {\textbf{YetiVariable}} is a sub-class of~\verb+YetiCard+ representing a variable in YETI.
\item {\textbf{YetiType}} represents type of data in YETI, e.g. integer, float, double, long, boolean and char.
\item {\textbf{YetiRoutine}} represents constructor, method and function in YETI. 
\item {\textbf{YetiModule}} represents a module in YETI and stores one or more routines of the module.
\item {\textbf{YetiName}} represents a unique name assigned to each instance of~\verb+YetiRoutine+.
\item {\textbf{YetiCard}} represents a wild-card or a variable in YETI.
\item {\textbf{YetiIdentifier}} represents an identifier for an instance of a~\verb+YetiCard+.
\end{enumerate}
% if java binding example is required or instead of adding new steps if you want to show only java binding then for material check the msc thesis page 40 of test c code with Yeti.

\subsection{Construction of Test Cases} \label{sec:constructionOfTestCases}
YETI constructs test cases by creating objects of the classes under test and randomly calls methods with random inputs according to the parameter's-space. YETI splits input values into two types i.e. primitive data types and user-defined classes. For primitive data types as methods parameters, YETI in random strategy calls~\verb+Math.random()+ method to generate arithmetic values, which are converted to the required type using Java cast operation. In the case of user-defined classes as methods parameters YETI calls constructor or method to generate object of the class at run time. In the case, when the constructor requires another object, YETI recursively calls the constructor or method of that object. This process is continued till an object with an empty constructor or a constructor with only primitive types or the set level of recursion is reached.

\subsection{Call sequence of YETI}
% check testing jml code with yeti for more details.
The sequence diagram given in Figure~\ref{fig:yetiSequenceDiagram} depicts the interactions of processes and their order when a Java program in byte-code is tested by YETI for~\verb+n+ number of times using the default random strategy.  The steps involved are as follows:

\bigskip
\begin{figure}[H]
	\centering
	\includegraphics[width=15.5cm, height=11cm]{chapter3/sequenceDiagram.png}
	\bigskip
	\caption{Call sequence of YETI with Java binding}
	\label{fig:yetiSequenceDiagram}
\end{figure}
\bigskip

\begin{enumerate}
\item When the test starts, the test engine (\verb+YetiEngine+) instructs the test manager (\verb+YetiJavaTestManager+) to initiate the testing of given class (\verb+YetiJavaModule+) for~\verb+n+ number of times (\verb+testModuleForNumberofTimes+) using the test strategy (\verb+YetiRandomStrategy+).

\item The test manager creates (\verb+makeNextCall+) a thread (\verb+CallerThread+) which handles the testing of a given program. Threading is introduced for two reasons: (1) To enable the test manager to block/terminate the thread, which is stuck because of an infinite loop inside the method or taking too long because of recursive calls. (2) To increase the speed of testing process when multiple classes are under test.

\item The thread on instantiation, requests the test strategy (\verb+YetiRandomStrategy+) to fetch a routine (\verb+constructor/method+) from the given SUT (\verb+getNextRoutine+).

\item The test strategy random strategy selects (\verb+getRoutineAtRandom+) a routine from the class (\verb+YetiJavaModule+).

\item The thread requests the test strategy to generate the arguments (\verb+cards+) for the selected routine (\verb+getAllCards+).

 \item The test strategy (\verb+YetiRandomStrategy+) generates the required arguments and send them to the requesting thread.
 
 \item The thread tests the selected routine (\verb+YetiJavaMethod+) of the module with the generated arguments (\verb+makeCall+).
 
 \item The routine (\verb+YetiJavaRoutine+) is mapped to an instance of the class method (\verb+YetiJavaMethod+) with the help of class inheritance and dynamic binding. The (\verb+YetiJavaMethod+) executes the method under test with the supplied arguments using Java Reflection API (\verb+makeEffectiveCall+).
 
\item The output obtained from (\verb+makeEffectiveCall+) is evaluated against Java oracle that resides in the (\verb+makeCall+) method of (\verb+YetiJavaMethod+).

\end{enumerate}



\bigskip
\bigskip

\subsection{Command-line Options}
YETI is originally developed as a command line program, which can be initiated from the Command Line Interface (CLI) as shown in Figure~\ref{fig:yeticommand}. During this study a \verb+yeti.jar+ package is created which allows to set the main parameters and initiate YETI from GUI by double clicking the icon as shown in Figure~\ref{fig:yetiLauncher}. YETI is provided with several command line options which a tester can enable or disable according to the test requirement. These options are case insensitive and can be provided in any order as input to YETI from command line interface. As an example, a tester can use command line option $-nologs$ to bypass real-time logging and save processing power by reducing overheads. Table~\ref{table:cliOptions} includes some of the common command line options available in YETI.

\begin{center}
\begin{table}[H]
%\scriptsize
\caption{YETI command line options} % title of Table
\bigskip
%\centering
\hspace{-0.8cm}
\noindent\makebox[\textwidth]{
{\renewcommand{\arraystretch}{1.6}
\begin{tabular}{|l|l|} % centered columns (4 columns)
\hline

\textbf{Options}					&\textbf{Purpose} 								\\ \hline
-java, -Java						&To test Java programs	 						\\ \hline
-jml	, -JML						&To test JML programs							\\ \hline
-dotnet, -DOTNET				&To test .NET programs							\\ \hline
-ea								&To check code assertions 						\\ \hline
-nTests							&To specify number of tests						\\ \hline
-time							&To specify test time								\\ \hline
-initClass						&To use user-defined class for initialization			\\ \hline 
-msCalltimeout					&To set a time out for a method call				\\ \hline
-testModules					&To specify one or more modules to test 			\\ \hline
-rawlogs						&To print real-time test logs						\\ \hline
-nologs							&To omit real time logs 							\\ \hline
-yetiPath						&To specify path to the test modules				\\ \hline
-gui								&To show test session in GUI						\\ \hline
-help, -h						&To print the help about using YETI				\\ \hline
-DSSR							&To specify Dirt Spot Sweeping Random strategy 	\\ \hline
-ADFD							&To specify ADFD strategy \\ \hline
-ADFDPlus						&To specify ADFD$^+$ strategy \\ \hline
-noInstanceCap					&To remove cap on no. of specific type instances	\\ \hline
-branchCoverage					&To measure the branch coverage					\\ \hline
-tracesOutputFile				&To specify the file to store output traces			\\ \hline
-tracesInputFile					&To specify the file to input traces 					\\ \hline
-random						&To specify Random test strategy					\\ \hline
-printNumberOfCallsPerMethod	&To print the number of calls per method			\\ \hline
-randomPlus						&To specify Random plus test strategy				\\ \hline
-probabilityToUseNullValue		&To specify probability of inserting null values		\\ \hline
-randomPlusPeriodic				&To specify Random plus periodic test strategy		\\ \hline
-newInstanceInjectionProability	&To specify probability of inserting new objects		\\ \hline

\hline %inserts single line
\end{tabular}
}}
\bigskip
\label{table:cliOptions} % is used to refer this table in the text
\end{table}
\end{center}

\subsection{Execution}
YETI, developed in Java, is highly portable and can easily run on any operating system with Java Virtual Machine (JVM) installed. It can be executed from both the CLI and GUI. To execute YETI, it is necessary to specify the \verb+project+ and the relevant \verb+jar+ library files, particularly \verb+javassist.jar+ in the \verb+CLASSPATH+. The typical command to execute YETI from CLI is given in Figure~\ref{fig:yeticommand}.
\smallskip
\begin{figure}[H]
	\centering
	\frame{\includegraphics[width= 15.3cm, height = 1.5cm]{chapter3/commandLineYeti.png}}
	\smallskip
	\caption{Command to launch YETI from CLI}
	\label{fig:yeticommand}
\end{figure}
\smallskip
In this command YETI tests \verb+java.lang.String+ and \verb+yeti.test.YetiTest+ modules for \verb+10+ minutes using the default random strategy. Other CLI options are already indicated in Table~\ref{table:cliOptions}. To execute YETI from the GUI, \verb+YetiLauncher+ presented in Figure~\ref{fig:yetiLauncher} has been created for use in the present study.
\bigskip
\begin{figure}[H]
	\centering
	\frame{\includegraphics[width= 8cm, height = 9cm]{chapter3/yetiCommandGUI.pdf}}
	\smallskip
	\caption{GUI launcher of YETI}
	\label{fig:yetiLauncher}
\end{figure}


\subsection{Test Oracle}
Oracles in YETI are language-dependent. In the presence of program specifications, it checks for inconsistencies between the code and the specifications. In the absence of specifications, it checks for assertion violations, which are considered as failures. % if assert statements are included by the programmer. However in the absence of 
If specifications or assertions are absent, YETI performs robustness testing, which considers any undeclared runtime exceptions as failures. 

%If code contracts are available, YETI uses them as oracle, however, in their absence YETI uses undeclared runtime exceptions of the underlying language as oracle. The test cases revealing errors are reproduced at the end of each test session for unit and regression testing.
%YETI deals with the oracle problem in two ways. If available, it uses code-contracts as oracles, however in the absence of contracts it uses runtime exceptions as errors which is also known as robustness testing.

\subsection{Report}
YETI gives a complete test report at the end of each test session. The report contains all the successful calls with the name of the routines and the unique identifiers for the parameters in each execution. These identifiers are recorded with the assigned values to help in debugging the identified fault as shown in Figure~\ref{successReport}. 
\bigskip
\begin{figure}[H]
	\centering
	\frame{\includegraphics[width= 15cm, height = 3.5cm]{chapter3/yetiReport1.png}}
	\smallskip
	\caption{Successful method calls of YETI}
	\label{successReport}
\end{figure}

YETI separates the found bugs from successful executions to simplify the test report. This helps debuggers to easily track the origin of the problem rectification. When a bug is identified during testing, YETI saves the details and presents it in the bug report as shown in Figure \ref{bugReport}. The information includes all identifiers of the parameters the method call had along with the time at which the exception occurs.
\bigskip
\begin{figure}[H]
	\centering
	\frame{\includegraphics[width= 15cm, height = 3.5cm]{chapter3/yetiReport2.png}}
	\smallskip
	\caption{Sample of YETI bug report}
	\label{bugReport}
\end{figure}

\subsection{Graphical User Interface}
YETI supports a GUI that allows testers to monitor the test session and modify the characteristics in real time during test execution. It is useful to have the option of modifying the test parameters at run time and observing the test behaviour in response. Figure \ref{fig:yetiGUI_3} presents the YETI GUI comprising of thirteen labelled components.

%\begin{figure}[h]
%	\centering
%	%\frame{\includegraphics[width= 15cm, height = 9.8cm]{chapter3/yetiGUI.png}}
%	\includegraphics[width= 15cm, height = 9.8cm]{chapter3/yetiGUI.png}
%	\caption{GUI of YETI}
%	\label{fig:yetiGUI1}
%\end{figure}

\begin{sidewaysfigure}[htp]
\centering
\centerline{\includegraphics[width=23cm,height=16cm]{chapter3/yetiGUI.png}}
%\includegraphics[width=14cm,height=20cm]{myfigures/plan/project_table.pdf}
\caption{GUI front-end of YETI}
\label{fig:yetiGUI_3}
\end{sidewaysfigure}



\begin{enumerate}

\item \textbf{Menu bar:} contains two menu items i.e. Yeti and File.
\begin{enumerate}
\item \textbf{Yeti menu:} provides details of YETI contributors and option to quit the GUI.
\item \textbf{File menu:} provides an option to rerun the previously executed scripts.
\end{enumerate}
\item \textbf{Slider of \% null values:} displays the set probability of null values in percentage used as null instance for each variable. The default value of the probability is 10\%. 
\item \textbf{Slider of \% new variables:} displays the set probability of creating new instances at each call. The default value of the probability is 10\%. 
\item \textbf{Text-box of Max variables per type:} displays the number of variables created for a given type. The default value is 1000.
\item \textbf{Progress bar of testing session:} displays the test progress as a percentage.
\item \textbf{Slider of strategy:} displays the set random strategy for the test session. Each strategy has its control to change its various parameters. 
\item \textbf{Module Name:} shows the list of modules under test. 
\item \textbf{Graph window 1:} displays the total number of unique failures over time in the module under test.
\item \textbf{Graph window 2:} displays the total number of calls over time to the module under test.
\item \textbf{Routine's progress:} displays test progress of each routine in the module represented by four colours. Mostly green and red colour appears indicating successful and unsuccessful calls respectively. Occasionally black and yellow colours appear indicating no calls and incomplete calls respectively.
\item \textbf{Graph window 3:} displays the total number of failures over time in the module under test. 
\item \textbf{Graph window 4:} displays the total number of variables over time generated by YETI in the test session.
%\item displays all the routines in the module under test with a rectangle.
%Each rectangle presents the results of calls of the routine. The rectangle can have in 4 colors. Black indicates no any calls of this routine. Green indicates that has successful calls of this routine. Red indicates that this routine is called unsuccessfully which means that the call to this routine results in an exception. Yellow indicates undecidable calls, for example if a call cannot finish in predefined time and Yeti stops this call, in this case yeti cannot decide this call is successful or unsuccessful. The text next the routines name show how many calls of this routine and text displays percentage of passed, failed and undescided when the cursor over the rectangle.
%\item displays a table which contains the unique faults are detected by Yeti. It records the detail of exceptions.
%\item Window No 5 displays colored rectangles: one for each constructor and method under test. Each rectangle represents the calls to a constructor or a method.
%\item The colors in a rectangle have the following meaning:
%\item Green indicates successful calls (✓). A successful call is one that does not raise an exception or if it does, the method or the constructor declares to throw it.
%\item Red indicates failed calls (X). A failed call results from raised RuntimeException or one of its subclasses.
%\item Yellow indicates “undecidable” calls (?). A call is “undecidable” if for some reason it takes too long to complete and needs to be stopped, or if a YetiSecurityException (custom exception in YETI) is thrown.
\item \textbf{Report section:} displays the number of unique failures by date and time, location and type detected in the module under test. 
\end{enumerate}


\section{Summary}
The chapter explains in detail the automated random testing tool YETI which is being used in this study. YETI has been thoroughly reviewed including an overview, design, core infrastructure, strategy, language-specific binding, construction of test cases, command line options, execution, test oracle, report generation and graphical user interface.


%The main features of all the tools are noted in the following table.



%\begin{figure}[h]
%	\centering
%	\includegraphics[scale=0.6]{chapter2/tools.jpg}
%	\caption{Summary of automated testing tools}
%\end{figure}




%\section{Conclusion}


% ------------------------------------------------------------------------


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
